-{ extension 'match' }
local internalmodel = require 'internalmodel'
local externalapi = require 'externalapi'
local Q = require 'metalua.treequery'
require 'metalua.walk'
require 'metalua.walk.bindings'


local M = {}

local function pdown (node,parent)
     print (tostring(node.tag) .. " down")
end
  
local function pup (node, parent)
   print (tostring(node.tag).. " up")     
end


-- define if a node is a block
local function supportedblock(node)
  return node.tag =="Function"
end

-- create a block from node
local function createblock(block)
     local b =   internalmodel._block()
     match block with
      | `Function{param, body} ->
         b.sourcerange.min = block.lineinfo.first.offset
         b.sourcerange.max = block.lineinfo.last.offset
      | _ ->
     end
     return b
end

-- define if a node is a supported expression
local function supportedexpr(node)
  return node.tag =="Index" or node.tag =="Id" or node.tag=="Call" or node.tag == "Invoke"
end


local idToBlock = {}
local handledIdentifier = {}
-- create an expr from node
local function createexpr(expr,_block)
   match expr with
    | `Id { name } ->
         -- create identifier
         local _identifier = internalmodel._identifier()
         -- we store the block which hold this node 
         -- to be able to define   
         idToBlock[expr]= _block
         handledIdentifier[expr]= _identifier
         return _identifier                                   
    | `Index { innerexpr, `String{f} } ->
         -- create index
         local e = createexpr(innerexpr,_block)
         if e then return internalmodel._index(e,f) end
    | `Call{innerexpr, ...} ->
         -- create call 
         local e = createexpr(innerexpr,_block)
         if e then return internalmodel._call(e) end
    | `Invoke{innerexpr,`String{f},...} ->
         -- create invoke
         local e = createexpr(innerexpr,_block)
         if e then return internalmodel._invoke(f,e) end
    | _ ->
   end
   
   return nil
end


local handledexpr = {}

-- create block and expression node
local function createTreeStructure(ast) 
  local internalcontent = internalmodel._internalcontent()
  local b= internalmodel._block()
  internalcontent.content = b
  local blocks = {b}
  b.sourcerange.min = ast.lineinfo.first.offset
  b.sourcerange.max = ast.lineinfo.last.offset
  
  local function down (node,parent)
    if supportedblock(node) then
       -- create the block
       local b = createblock(node)
       -- add it to parent block
       table.insert(blocks[#blocks].content, b) 
       -- enqueue the last block to know the "current" block
       table.insert(blocks,b)
    elseif supportedexpr(node) then
       -- create expr
       local e = createexpr(node,blocks[#blocks])
       -- add it to parent block
       if e then
          table.insert(blocks[#blocks].content, e)
          -- store this node as supported expr
          handledexpr[node] = e
       end  
    end
  end
  
  local function up (node, parent)
    if supportedblock(node) then
       -- dequeue the last block to know the "current" block
       table.remove(blocks,#blocks)
    end     
  end
  
  Q(ast):not_under(supportedexpr):foreach(down,up)    
  return internalcontent
end



local function createType(node,position)
    match node with
    | `Call{ `Id "require", `String {modulename}} ->
        return externalapi._moduletyperef(modulename,position)
    | _ ->
    end
    -- if node is an expression supported
    local supportedexpr = handledexpr[node]
    if supportedexpr then
      return externalapi._exprtyperef(supportedexpr,position)
    end
    
end
 
local function getType(node, itemname)
   match node with
   | `Local {ids, inits} ->
      
      local init = nil
      local returnposition = 1
      for i,id in ipairs(ids) do
         local idname = id[1]
         
         if init and (init.tag == "Call" or init.tag == "Invoke") then
            returnposition= returnposition+1
         else
            init = inits[i]                  
         end
     
         if itemname == idname then
            -- create type
            local type = createType(init,returnposition)
            
            -- return data
            return id, type 
         end
      end
   | _ ->
   end
end

local function createLocalVars(internalcontent,ast)
  
  local locals, globals = bindings( ast )

  -- create locals var
  for node, namesAndOccurrences in pairs(locals) do
      for name, occurences in pairs(namesAndOccurrences) do
            -- create item
            local _item = externalapi._item(name)
            
            -- get type and id 
            local id, type = getType(node, name)
            if id then
               if type then _item.type = type end
               -- add declaration as occurences
               table.insert(_item.occurences, handledIdentifier[id])
               
               -- add occurences
               for _,occurence in ipairs(occurences) do
                  local _identifier = handledIdentifier[occurence]
                  if _identifier then
                    table.insert(_item.occurences, _identifier)
                    _identifier.definition = _item 
                  end 
               end
     
               -- add item to block
               local _block = idToBlock[id]
               table.insert(_block.localvars,{item=_item,scope = {min=0,max=0}})
            end  
      end
   end
  
  
  -- create globals var
--  for name, occurrences in pairs( globals ) do
--     -- TODO
--     -- local item = externalapi._item()
--     -- foreach occurence blabla
--     --table.insert(internalcontent.unknownglobalvars,item)    
--  end
end
 
function M.createInternalContent (ast)
   -- create block and expression node
   local internalcontent = createTreeStructure(ast)
   
   -- create Local vars (Items)
   createLocalVars(internalcontent,ast)
   
   return internalcontent
end

return M 